#!/usr/bin/env bash
# Cognitify configure script
# (c) 2026 Ramon Brooker <rbrooker@aeo3.io>

set -e

# Default values
PREFIX="${PREFIX:-/usr/local}"
ETC_DIR="${ETC_DIR:-/etc}"
HOME_DIR="${HOME_DIR:-$HOME}"
INSTALL_USER="${INSTALL_USER:-${SUDO_USER:-${USER}}}"
INCLUDE_GUI="${INCLUDE_GUI:-no}"
SKIP_PACKAGES="${SKIP_PACKAGES:-no}"
DOCKER_MODE="${DOCKER_MODE:-no}"
EXTENDED_COMPLETIONS="${EXTENDED_COMPLETIONS:-no}"
EXTENDED_HOME_FILES="${EXTENDED_HOME_FILES:-no}"

# Output file
CONFIG_FILE="config.mk"

# Detect if running in Docker/container environment
detect_docker() {
    # Check for common Docker/container indicators
    if [[ -f /.dockerenv ]] || \
       [[ -n "${container:-}" ]] || \
       [[ -f /proc/1/cgroup ]] && grep -qa docker /proc/1/cgroup 2>/dev/null || \
       [[ -f /proc/1/cgroup ]] && grep -qa kubepods /proc/1/cgroup 2>/dev/null; then
        return 0
    fi
    return 1
}

# Detect distribution
# Uses the same detection logic as ddistro() in libCognitifyHelpers for consistency
# This function sets global variables needed for the build system
detect_distro() {
    # Source the appropriate OS release file to get distribution information
    # This matches the logic in ddistro() for consistency
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        DISTRO_ID="$ID"
        DISTRO_VERSION_ID="$VERSION_ID"
        # Normalize RHEL ID variants
        if [[ "$ID" == "redhat" ]]; then
            DISTRO_ID="rhel"
        fi
    elif [[ -f /etc/oracle-release ]]; then
        . /etc/oracle-release
        DISTRO_ID="oracle"
    elif [[ -f /etc/redhat-release ]]; then
        # Fallback for older systems without /etc/os-release
        # Try to extract version from redhat-release
        if grep -qi "red hat enterprise" /etc/redhat-release 2>/dev/null; then
            DISTRO_ID="rhel"
            DISTRO_VERSION_ID=$(grep -oE '[0-9]+\.[0-9]+' /etc/redhat-release | head -1 || echo "")
        else
            DISTRO_ID="rhel"
        fi
    else
        DISTRO_ID="unknown"
    fi
    
    # Auto-detect Docker mode if not explicitly set
    if [[ "$DOCKER_MODE" = "no" ]] && detect_docker; then
        DOCKER_MODE="yes"
    fi

    # Determine package manager using command -v (matches improved ddistro() logic)
    # This ensures we detect what's actually available, not just what should be there
    if command -v apt-get >/dev/null 2>&1; then
        PKG_MANAGER="apt-get"
    elif command -v dnf >/dev/null 2>&1; then
        PKG_MANAGER="dnf"
    elif command -v yum >/dev/null 2>&1; then
        PKG_MANAGER="yum"
    elif command -v zypper >/dev/null 2>&1; then
        PKG_MANAGER="zypper"
    else
        PKG_MANAGER="unknown"
    fi

    # Set install and update commands based on detected package manager
    case "$PKG_MANAGER" in
        apt-get)
            PKG_MANAGER_INSTALL="apt-get install -y"
            PKG_MANAGER_UPDATE="apt-get update"
            ;;
        dnf)
            PKG_MANAGER_INSTALL="dnf install -y"
            PKG_MANAGER_UPDATE="dnf check-update || true"
            ;;
        yum)
            PKG_MANAGER_INSTALL="yum install -y"
            PKG_MANAGER_UPDATE="yum check-update || true"
            ;;
        zypper)
            PKG_MANAGER_INSTALL="zypper --non-interactive install --auto-agree-with-licenses"
            PKG_MANAGER_UPDATE="zypper refresh"
            ;;
        *)
            PKG_MANAGER_INSTALL=""
            PKG_MANAGER_UPDATE=""
            ;;
    esac
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prefix=*)
                PREFIX="${1#*=}"
                shift
                ;;
            --prefix)
                PREFIX="$2"
                shift 2
                ;;
            --etc-dir=*)
                ETC_DIR="${1#*=}"
                shift
                ;;
            --etc-dir)
                ETC_DIR="$2"
                shift 2
                ;;
            --user=*)
                INSTALL_USER="${1#*=}"
                shift
                ;;
            --user)
                INSTALL_USER="$2"
                shift 2
                ;;
            --root)
                INSTALL_USER="root"
                shift
                ;;
            --include-gui)
                INCLUDE_GUI="yes"
                shift
                ;;
            --skip-packages)
                SKIP_PACKAGES="yes"
                shift
                ;;
            --docker)
                DOCKER_MODE="yes"
                shift
                ;;
            --extended-completions)
                EXTENDED_COMPLETIONS="yes"
                shift
                ;;
            --extended-home-files)
                EXTENDED_HOME_FILES="yes"
                shift
                ;;
            --distro-package=*)
                DISTRO_PACKAGE="${1#*=}"
                shift
                ;;
            --distro-package)
                DISTRO_PACKAGE="$2"
                shift 2
                ;;
            --help|-h)
                cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --prefix=DIR          Installation prefix (default: /usr/local)
  --etc-dir=DIR          System configuration directory (default: /etc)
  --user=USER            User to install dotfiles for (default: current user)
  --root                 Install dotfiles for root user (equivalent to --user=root)
  --include-gui          Include GUI packages in installation
  --skip-packages        Skip package installation
  --docker               Use Docker/container mode (uses pared down package list)
  --extended-completions Install extended completions (kubectl, helm, terraform, etc.)
  --extended-home-files Install extended home files (terraformrc, shellcheckrc, etc.)
  --distro-package=DISTRO Create distribution-specific package (e.g., rocky, ubuntu)
  --help, -h             Show this help message

Environment variables:
  PREFIX                 Installation prefix
  ETC_DIR                System configuration directory
  INSTALL_USER           User for dotfiles installation
  INCLUDE_GUI            Set to 'yes' to include GUI packages
  SKIP_PACKAGES          Set to 'yes' to skip package installation
  DOCKER_MODE            Set to 'yes' to use Docker/container mode
  EXTENDED_COMPLETIONS   Set to 'yes' to install extended completions
  EXTENDED_HOME_FILES    Set to 'yes' to install extended home files

Examples:
  $0 --prefix=/usr --include-gui
  $0 --user=john --skip-packages
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Run '$0 --help' for usage information." >&2
                exit 1
                ;;
        esac
    done
}

# Generate config.mk
generate_config() {
    detect_distro
    
    cat > "$CONFIG_FILE" <<EOF
# Cognitify build configuration
# Generated by configure script on $(date)

# Installation paths
PREFIX = ${PREFIX}
ETC_DIR = ${ETC_DIR}
CONFIG_DEST = \$(ETC_DIR)/bash.bashrc.d
COMPLETIONS_DEST = \$(ETC_DIR)/bash_completion.d
HOME_FILES_DEST = \$(shell getent passwd ${INSTALL_USER} | cut -d: -f6)

# User and group
INSTALL_USER = ${INSTALL_USER}
GROUP_NAME = cognitify

# Distribution information
DISTRO_ID = ${DISTRO_ID}
DISTRO_VERSION_ID = ${DISTRO_VERSION_ID:-}
PKG_MANAGER = ${PKG_MANAGER}
PKG_MANAGER_INSTALL = ${PKG_MANAGER_INSTALL}
PKG_MANAGER_UPDATE = ${PKG_MANAGER_UPDATE}

# Build options
INCLUDE_GUI = ${INCLUDE_GUI}
SKIP_PACKAGES = ${SKIP_PACKAGES}
DOCKER_MODE = ${DOCKER_MODE}
EXTENDED_COMPLETIONS = ${EXTENDED_COMPLETIONS}
EXTENDED_HOME_FILES = ${EXTENDED_HOME_FILES}

# Source directories
SRC_DIR = src
CONFIG_SRC = \$(SRC_DIR)/bash.bashrc.d
HOME_FILES_SRC = \$(SRC_DIR)/home-files
HOME_FILES_EXTENDED_SRC = \$(SRC_DIR)/home-files-extended
COMPLETIONS_SRC = \$(SRC_DIR)/completions
COMPLETIONS_EXTENDED_SRC = \$(SRC_DIR)/completions-extended
PACKAGES_DIR = \$(SRC_DIR)/packages
BIN_SRC = \$(SRC_DIR)/usr/local/bin
DISTRO_FILES_SRC = \$(SRC_DIR)/distro-files

# Version
VERSION = $(cat version 2>/dev/null || echo "0.0.1")
EOF

    echo "Configuration generated: $CONFIG_FILE"
    echo ""
    echo "Configuration summary:"
    echo "  Distribution: ${DISTRO_ID} ${DISTRO_VERSION_ID:-}"
    echo "  Package Manager: ${PKG_MANAGER}"
    echo "  Installation Prefix: ${PREFIX}"
    echo "  Configuration Directory: ${ETC_DIR}"
    echo "  Install User: ${INSTALL_USER}"
    echo "  Include GUI: ${INCLUDE_GUI}"
    echo "  Skip Packages: ${SKIP_PACKAGES}"
    echo "  Docker Mode: ${DOCKER_MODE}"
    echo "  Extended Completions: ${EXTENDED_COMPLETIONS}"
    echo "  Extended Home Files: ${EXTENDED_HOME_FILES}"
    echo ""
    echo "Next steps:"
    echo "  make          - Build the project"
    echo "  make install   - Install files and packages"
    echo "  make help      - Show more targets"
}

# Main
parse_args "$@"

# Handle distro packaging (must be after parse_args)
if [[ -n "${DISTRO_PACKAGE:-}" ]]; then
    if [[ ! -f "package-distro.sh" ]]; then
        echo "Error: package-distro.sh not found" >&2
        exit 1
    fi
    chmod +x package-distro.sh
    ./package-distro.sh "$DISTRO_PACKAGE"
    exit $?
fi

generate_config

