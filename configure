#!/usr/bin/env bash
# Cognitify configure script
# (c) 2026 Ramon Brooker <rbrooker@aeo3.io>

set -e

# Default values
PREFIX="${PREFIX:-/usr/local}"
ETC_DIR="${ETC_DIR:-/etc}"
HOME_DIR="${HOME_DIR:-$HOME}"
INSTALL_USER="${INSTALL_USER:-${SUDO_USER:-${USER}}}"
SKIP_PACKAGES="${SKIP_PACKAGES:-no}"
DOCKER_MODE="${DOCKER_MODE:-no}"
HOSTNAME_COLOUR="${HOSTNAME_COLOUR:-}"
USERNAME_COLOUR="${USERNAME_COLOUR:-}"
PWD_COLOUR="${PWD_COLOUR:-}"
COLOUR_PROFILE="${COLOUR_PROFILE:-}"

# Output file
CONFIG_FILE="config.mk"

# Detect if running in Docker/container environment
detect_docker() {
    # Check for common Docker/container indicators
    if [[ -f /.dockerenv ]] || \
       [[ -n "${container:-}" ]] || \
       [[ -f /proc/1/cgroup ]] && grep -qa docker /proc/1/cgroup 2>/dev/null || \
       [[ -f /proc/1/cgroup ]] && grep -qa kubepods /proc/1/cgroup 2>/dev/null; then
        return 0
    fi
    return 1
}

# Detect distribution
detect_distro() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        DISTRO_ID="$ID"
        DISTRO_VERSION_ID="$VERSION_ID"
        # Normalize RHEL ID variants
        if [[ "$ID" == "redhat" ]]; then
            DISTRO_ID="rhel"
        fi
    elif [[ -f /etc/oracle-release ]]; then
        . /etc/oracle-release
        DISTRO_ID="oracle"
    elif [[ -f /etc/redhat-release ]]; then
        # Fallback for older systems without /etc/os-release
        # Try to extract version from redhat-release
        if grep -qi "red hat enterprise" /etc/redhat-release 2>/dev/null; then
            DISTRO_ID="rhel"
            DISTRO_VERSION_ID=$(grep -oE '[0-9]+\.[0-9]+' /etc/redhat-release | head -1 || echo "")
        else
            DISTRO_ID="rhel"
        fi
    else
        DISTRO_ID="unknown"
    fi
    
    # Auto-detect Docker mode if not explicitly set
    if [[ "$DOCKER_MODE" = "no" ]] && detect_docker; then
        DOCKER_MODE="yes"
    fi

    # Determine package manager
    if command -v apt-get >/dev/null 2>&1; then
        PKG_MANAGER="apt-get"
        PKG_MANAGER_INSTALL="apt-get install -y"
        PKG_MANAGER_UPDATE="apt-get update"
    elif command -v dnf >/dev/null 2>&1; then
        PKG_MANAGER="dnf"
        PKG_MANAGER_INSTALL="dnf install -y"
        PKG_MANAGER_UPDATE="dnf check-update || true"
    elif command -v yum >/dev/null 2>&1; then
        PKG_MANAGER="yum"
        PKG_MANAGER_INSTALL="yum install -y"
        PKG_MANAGER_UPDATE="yum check-update || true"
    elif command -v zypper >/dev/null 2>&1; then
        PKG_MANAGER="zypper"
        PKG_MANAGER_INSTALL="zypper --non-interactive install --auto-agree-with-licenses"
        PKG_MANAGER_UPDATE="zypper refresh"
    else
        PKG_MANAGER="unknown"
        PKG_MANAGER_INSTALL=""
        PKG_MANAGER_UPDATE=""
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prefix=*)
                PREFIX="${1#*=}"
                shift
                ;;
            --prefix)
                PREFIX="$2"
                shift 2
                ;;
            --etc-dir=*)
                ETC_DIR="${1#*=}"
                shift
                ;;
            --etc-dir)
                ETC_DIR="$2"
                shift 2
                ;;
            --user=*)
                INSTALL_USER="${1#*=}"
                shift
                ;;
            --user)
                INSTALL_USER="$2"
                shift 2
                ;;
            --root)
                INSTALL_USER="root"
                shift
                ;;
            --include-gui)
                INCLUDE_GUI="yes"
                shift
                ;;
            --skip-packages)
                SKIP_PACKAGES="yes"
                shift
                ;;
            --docker)
                DOCKER_MODE="yes"
                shift
                ;;
            --distro-package=*)
                DISTRO_PACKAGE="${1#*=}"
                shift
                ;;
            --distro-package)
                DISTRO_PACKAGE="$2"
                shift 2
                ;;
            --hostname-colour=*)
                HOSTNAME_COLOUR="${1#*=}"
                shift
                ;;
            --hostname-colour)
                HOSTNAME_COLOUR="$2"
                shift 2
                ;;
            --colour-profile=*)
                COLOUR_PROFILE="${1#*=}"
                shift
                ;;
            --colour-profile)
                COLOUR_PROFILE="$2"
                shift 2
                ;;
            --help|-h)
                cat <<EOF
Usage: $0 [OPTIONS]

Options:
  --prefix=DIR          Installation prefix (default: /usr/local)
  --etc-dir=DIR          System configuration directory (default: /etc)
  --user=USER            User to install dotfiles for (default: current user)
  --root                 Install dotfiles for root user (equivalent to --user=root)
  --skip-packages        Skip package installation
  --docker               Use Docker/container mode (uses pared down package list)
  --hostname-colour=COLOUR Set default hostname colour (e.g., AZURE, BRIGHT_PINK, OLIVE)
  --colour-profile=PROFILE Set colour profile (use 'random' to randomly select from colour-combos)
  --distro-package=DISTRO Create distribution-specific package (e.g., rocky, ubuntu)
  --help, -h             Show this help message

Environment variables:
  PREFIX                 Installation prefix
  ETC_DIR                System configuration directory
  INSTALL_USER           User for dotfiles installation
  SKIP_PACKAGES          Set to 'yes' to skip package installation
  DOCKER_MODE            Set to 'yes' to use Docker/container mode
  HOSTNAME_COLOUR        Set default hostname colour (e.g., AZURE, BRIGHT_PINK, OLIVE)
  COLOUR_PROFILE         Set colour profile (use 'random' to randomly select from colour-combos)

Examples:
  $0 --prefix=/usr
  $0 --user=john --skip-packages
  $0 --hostname-colour=AZURE
  $0 --hostname-colour=BRIGHT_PINK --skip-packages
  $0 --colour-profile=random
  $0 --colour-profile=random --skip-packages
EOF
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                echo "Run '$0 --help' for usage information." >&2
                exit 1
                ;;
        esac
    done
}

# Parse colour-combos file and randomly select a combination
select_random_colour_profile() {
    local colour_file="colour-combos"
    
    if [[ ! -f "$colour_file" ]]; then
        echo "Warning: colour-combos file not found, cannot select random profile" >&2
        return 1
    fi
    
    # Extract valid colour combination lines (skip markdown syntax, comments, empty lines)
    local combinations
    combinations=$(awk '
        NF && \
        $1 !~ /^#/ && \
        $1 !~ /^```/ && \
        $1 !~ /^\*\*/ && \
        $1 !~ /^\(c\)/ && \
        $1 !~ /^Copy/ && \
        $1 !~ /^Or/ && \
        $1 !~ /^The/ && \
        $1 !~ /^export/ && \
        $1 !~ /^Available/ && \
        $1 !~ /^Format:/ && \
        $1 !~ /^-/ && \
        $1 !~ /^##/ {
            # Check if line has exactly 3 fields (hostname, username, pwd colours)
            # and fields look like colour names (all caps, may contain underscores)
            if (NF == 3 && $1 ~ /^[A-Z_]+$/ && $2 ~ /^[A-Z_]+$/ && $3 ~ /^[A-Z_]+$/) {
                print $1 " " $2 " " $3
            }
        }
    ' "$colour_file")
    
    if [[ -z "$combinations" ]]; then
        echo "Warning: No valid colour combinations found in colour-combos file" >&2
        return 1
    fi
    
    # Count combinations and select a random one
    local count
    count=$(echo "$combinations" | wc -l)
    
    # Generate random number between 1 and count
    local random_line
    if command -v shuf >/dev/null 2>&1; then
        random_line=$(echo "$combinations" | shuf -n 1)
    elif command -v gshuf >/dev/null 2>&1; then
        random_line=$(echo "$combinations" | gshuf -n 1)
    else
        # Fallback: use $RANDOM if available, otherwise use a simple hash
        local line_num
        if [[ -n "${RANDOM:-}" ]]; then
            line_num=$((RANDOM % count + 1))
        else
            # Use a simple hash based on current time
            line_num=$(( $(date +%s) % count + 1 ))
        fi
        random_line=$(echo "$combinations" | sed -n "${line_num}p")
    fi
    
    # Extract the three colours
    HOSTNAME_COLOUR=$(echo "$random_line" | awk '{print $1}')
    USERNAME_COLOUR=$(echo "$random_line" | awk '{print $2}')
    PWD_COLOUR=$(echo "$random_line" | awk '{print $3}')
    
    echo "Selected random colour profile:"
    echo "  Hostname: ${HOSTNAME_COLOUR}"
    echo "  Username: ${USERNAME_COLOUR}"
    echo "  PWD: ${PWD_COLOUR}"
}

# Generate config.mk
generate_config() {
    detect_distro
    
    # Handle colour profile selection
    if [[ "$COLOUR_PROFILE" == "random" ]]; then
        select_random_colour_profile
    fi
    
    cat > "$CONFIG_FILE" <<EOF
# Cognitify build configuration
# Generated by configure script on $(date)

# Installation paths
PREFIX = ${PREFIX}
ETC_DIR = ${ETC_DIR}
CONFIG_DEST = \$(ETC_DIR)/bash.bashrc.d
COMPLETIONS_DEST = \$(ETC_DIR)/bash_completion.d
HOME_FILES_DEST = \$(shell getent passwd ${INSTALL_USER} | cut -d: -f6)

# User and group
INSTALL_USER = ${INSTALL_USER}
GROUP_NAME = cognitify

# Distribution information
DISTRO_ID = ${DISTRO_ID}
DISTRO_VERSION_ID = ${DISTRO_VERSION_ID:-}
PKG_MANAGER = ${PKG_MANAGER}
PKG_MANAGER_INSTALL = ${PKG_MANAGER_INSTALL}
PKG_MANAGER_UPDATE = ${PKG_MANAGER_UPDATE}

# Build options
SKIP_PACKAGES = ${SKIP_PACKAGES}
DOCKER_MODE = ${DOCKER_MODE}
HOSTNAME_COLOUR = ${HOSTNAME_COLOUR}
USERNAME_COLOUR = ${USERNAME_COLOUR}
PWD_COLOUR = ${PWD_COLOUR}

# Source directories
SRC_DIR = src
CONFIG_SRC = \$(SRC_DIR)/bash.bashrc.d
HOME_FILES_SRC = \$(SRC_DIR)/home-files
COMPLETIONS_SRC = \$(SRC_DIR)/completions
PACKAGES_DIR = \$(SRC_DIR)/packages
BIN_SRC = \$(SRC_DIR)/usr/local/bin
DISTRO_FILES_SRC = \$(SRC_DIR)/distro-files

# Version
VERSION = $(cat version 2>/dev/null || echo "0.0.1")
EOF

    echo "Configuration generated: $CONFIG_FILE"
    echo ""
    echo "Configuration summary:"
    echo "  Distribution: ${DISTRO_ID} ${DISTRO_VERSION_ID:-}"
    echo "  Package Manager: ${PKG_MANAGER}"
    echo "  Installation Prefix: ${PREFIX}"
    echo "  Configuration Directory: ${ETC_DIR}"
    echo "  Install User: ${INSTALL_USER}"
    echo "  Skip Packages: ${SKIP_PACKAGES}"
    echo "  Docker Mode: ${DOCKER_MODE}"
    if [[ -n "${HOSTNAME_COLOUR}" ]]; then
        echo "  Hostname Colour: ${HOSTNAME_COLOUR}"
    fi
    if [[ -n "${USERNAME_COLOUR}" ]]; then
        echo "  Username Colour: ${USERNAME_COLOUR}"
    fi
    if [[ -n "${PWD_COLOUR}" ]]; then
        echo "  PWD Colour: ${PWD_COLOUR}"
    fi
    echo ""
    echo "Next steps:"
    echo "  make          - Build the project"
    echo "  make install   - Install files and packages"
    echo "  make help      - Show more targets"
}

# Main
parse_args "$@"

# Handle distro packaging (must be after parse_args)
if [[ -n "${DISTRO_PACKAGE:-}" ]]; then
    if [[ ! -f "package-distro.sh" ]]; then
        echo "Error: package-distro.sh not found" >&2
        exit 1
    fi
    chmod +x package-distro.sh
    ./package-distro.sh "$DISTRO_PACKAGE"
    exit $?
fi

generate_config

